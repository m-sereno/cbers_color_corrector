# -*- coding: utf-8 -*-

"""
/***************************************************************************
 CBERSColorCorrector
                                 A QGIS plugin
 This plugin corrects the color from CBERS images to match the database
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-08-01
        copyright            : (C) 2023 by Mateus Sereno
        email                : mateus.sereno@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Mateus Sereno'
__date__ = '2023-08-01'
__copyright__ = '(C) 2023 by Mateus Sereno'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import numpy as np
import requests
from typing import List

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (QgsProcessing,
                       QgsFeatureSink,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterFile,
                       QgsProcessingParameterFileDestination,
                       QgsRasterLayer,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingException,
                       QgsRasterFileWriter,
                       QgsRasterBlock,
                       QgsRasterPipe,
                       QgsRectangle)


class TileHistogram():
    def __init__(self, r_hist : np.ndarray, g_hist : np.ndarray, b_hist : np.ndarray):
        self.r_hist = r_hist
        self.g_hist = g_hist
        self.b_hist = b_hist

class TileCdf():
    def __init__(self, r_cdf : np.ndarray, g_cdf : np.ndarray, b_cdf : np.ndarray):
        self.r_cdf = r_cdf
        self.g_cdf = g_cdf
        self.b_cdf = b_cdf

class HistMatchingFunction():
    def __init__(self, r_func : np.ndarray, g_func : np.ndarray, b_func : np.ndarray):
        self.r_func = r_func
        self.g_func = g_func
        self.b_func = b_func

class BestMatchRequest():
    def __init__(self, embedding: np.ndarray):
        self.embedding = embedding

class BestMatchResponse():
    def __init__(self, best_match_cdf: TileCdf, similarity: float):
        self.best_match_cdf = best_match_cdf
        self.similarity = similarity


class CBERSColorCorrectorAlgorithm(QgsProcessingAlgorithm):
    
    OUTPUT = 'OUTPUT'
    INPUT = 'INPUT'

    def initAlgorithm(self, config):
        self.addParameter(
            QgsProcessingParameterFile(
                self.INPUT,
                self.tr('CBERS IMAGE FILE'),
                behavior=QgsProcessingParameterFile.File,
                fileFilter='All (*.*)'
            )
        )

        self.addParameter(
            QgsProcessingParameterFileDestination(
                self.OUTPUT,
                self.tr('OUTPUT DESTINATION')
            )
        )
    
    def euclidean_distance(self, v1, v2):
        """Calculate the Euclidean distance between two vectors."""
        return np.sqrt(np.sum((v1 - v2) ** 2))
    
    def tile_hist_distance(self, h1 : TileHistogram, h2 : TileHistogram):
        """Calculate the Distance between two tile histograms."""
        dist_r = self.euclidean_distance(h1.r_hist, h2.r_hist)
        dist_g = self.euclidean_distance(h1.g_hist, h2.g_hist)
        dist_b = self.euclidean_distance(h1.b_hist, h2.b_hist)

        return dist_r + dist_g + dist_b
    
    def find_most_diverse(self, all_histograms, M):
        """Find the M most diverse vectors from the list."""
        
        # Create a copy of the list so we can modify it
        hists = list(all_histograms)
        
        # Start with a randomly chosen histogram
        diverse_picks = [hists.pop(np.random.randint(len(hists)))]

        # Repeat until we have selected M histograms
        while len(diverse_picks) < M:
            # For each tile histogram, calculate the minimum distance to the selected ones
            min_distances = [min(self.tile_hist_distance(self, v, selected) for selected in diverse_picks)
                            for v in hists]
            
            # Select the vector with the maximum minimum distance
            diverse_picks.append(hists.pop(np.argmax(min_distances)))

        return diverse_picks
    
    def get_histogram_matching_function_band(self, cdf1_band : np.ndarray, cdf2_band : np.ndarray):
        matching_function_band = np.zeros_like(cdf1_band)

        for i in range(256):
            diff = np.abs(cdf1_band[i] - cdf2_band[i])
            idx = np.argmin(diff)
            matching_function_band[i] = idx

        return matching_function_band
    
    def get_histogram_matching_function(self, cdf1 : TileCdf, cdf2 : TileCdf):
        matching_function = HistMatchingFunction()

        matching_function.r_func = self.get_histogram_matching_function_band(cdf1.r_cdf, cdf2.r_cdf)
        matching_function.g_func = self.get_histogram_matching_function_band(cdf1.g_cdf, cdf2.g_cdf)
        matching_function.b_func = self.get_histogram_matching_function_band(cdf1.b_cdf, cdf2.b_cdf)

        return matching_function
    
    def compute_average_function(self, hist_matching_functions : List[HistMatchingFunction]):
        avg_f = HistMatchingFunction()

        for value in range(256):
            avg_f.r_func = np.mean([func[value].r_func for func in hist_matching_functions])
            avg_f.g_func = np.mean([func[value].g_func for func in hist_matching_functions])
            avg_f.b_func = np.mean([func[value].b_func for func in hist_matching_functions])

        return avg_f

    def processAlgorithm(self, parameters, context, feedback):
        input_file = self.parameterAsFile(parameters, self.INPUT, context)
        output_file = self.parameterAsFileOutput(parameters, self.OUTPUT, context)

        # Load the raster
        feedback.pushInfo('Loading the raster layer...')
        input_layer = QgsRasterLayer(input_file, "input")

        # Ensure the layer was loaded successfully
        if not input_layer.isValid():
            raise QgsProcessingException("Could not load layer")
        
        provider = input_layer.dataProvider()
        width = input_layer.width()
        height = input_layer.height()

        feedback.pushInfo(str(height))

        provider = input_layer.dataProvider()

        all_histograms = []

        for y_start in range(0, width, 512):
            for x_start in range(0, height, 512):
                
                # Define the extent of the current tile:
                extent = QgsRectangle(
                    input_layer.extent().xMinimum() + x_start * input_layer.rasterUnitsPerPixelX(),
                    input_layer.extent().yMinimum() + y_start * input_layer.rasterUnitsPerPixelY(),
                    input_layer.extent().xMinimum() + (x_start + 512) * input_layer.rasterUnitsPerPixelX(),
                    input_layer.extent().yMinimum() + (y_start + 512) * input_layer.rasterUnitsPerPixelY()
                )

                # Calculate the histogram
                tile_hist = TileHistogram([], [], [])
                hist_list = list()

                for band_index in range(1, 4):

                    # Read tile data:
                    tile : QgsRasterBlock = provider.block(band_index, extent, 512, 512)
                    data = tile.data()

                    # Compute histogram:
                    histogram, bin_edges = np.histogram(data, bins=256, range=(0, 256))
                    hist_list.append(histogram)
                
                tile_hist.r_hist = hist_list[0]
                tile_hist.g_hist = hist_list[1]
                tile_hist.b_hist = hist_list[2]

                all_histograms.append(tile_hist)
        
        diverse_histograms = self.find_most_diverse(all_histograms, 20)

        hist_matching_functions = []

        for hist_index in range(0, len(diverse_histograms)):
            hist : TileHistogram = diverse_histograms[hist_index]
            cdf = TileCdf()
            cdf.r_cdf = np.cumsum(hist.r_hist)
            cdf.g_cdf = np.cumsum(hist.g_hist)
            cdf.b_cdf = np.cumsum(hist.b_hist)

            # TODO: CALCULATE EMBEDDING.

            best_match_req = BestMatchRequest()

            url = 'https://server-url/endpoint'

            res = requests.post(url, json=best_match_req)
            best_match_res : BestMatchResponse = res.json()

            res_cdf = best_match_res.best_match_cdf

            hist_mapping_f = self.get_histogram_matching_function(cdf, res_cdf)
            hist_matching_functions.append(hist_mapping_f)

        avg_hist_matching_f = self.compute_average_function(hist_matching_functions)

        # TODO: Apply the function to the original image.
        # TODO: The result will be saved to a new file

        writer = QgsRasterFileWriter(output_file)

        pipe = QgsRasterPipe()
        if not pipe.set(input_layer.dataProvider().clone()):
            return False
        
        # Write raster file
        writer.writeRaster(pipe,
                          input_layer.rasterUnitsPerPixelX(),
                          input_layer.rasterUnitsPerPixelY(),
                          input_layer.extent(),
                          input_layer.crs())
        

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Adjust Raster Coloring'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'CBERS Color Corrector'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return CBERSColorCorrectorAlgorithm()
