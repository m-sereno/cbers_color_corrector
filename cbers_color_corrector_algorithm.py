# -*- coding: utf-8 -*-

"""
/***************************************************************************
 CBERSColorCorrector
                                 A QGIS plugin
 This plugin corrects the color from CBERS images to match the database
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-08-01
        copyright            : (C) 2023 by Mateus Sereno
        email                : mateus.sereno@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Mateus Sereno'
__date__ = '2023-08-01'
__copyright__ = '(C) 2023 by Mateus Sereno'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import numpy as np
import requests
from requests.auth import HTTPBasicAuth
from typing import Dict, List, Tuple, Union

from osgeo import gdal, ogr
from osgeo.gdal import Dataset

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (Qgis,
                       QgsProcessing,
                       QgsFeatureSink,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterFile,
                       QgsProcessingParameterFileDestination,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterString,
                       QgsRasterLayer,
                       QgsRasterDataProvider,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingException,
                       QgsRasterFileWriter,
                       QgsRasterBlock,
                       QgsRasterPipe,
                       QgsRectangle)

TILE_SIZE = 512
REWRITE_STEP_SIZE = 256
RANDOM_CHUNKS = 50
MISSING_PIXEL_TOL = 0.01

class TileHistogram():
    def __init__(self, r_hist : np.ndarray, g_hist : np.ndarray, b_hist : np.ndarray):
        self.r_hist = r_hist
        self.g_hist = g_hist
        self.b_hist = b_hist

class TileCdf():
    def __init__(self, r : np.ndarray, g : np.ndarray, b : np.ndarray):
        self.r = r
        self.g = g
        self.b = b

class HistMatchingFunction():
    def __init__(self, r_func : np.ndarray, g_func : np.ndarray, b_func : np.ndarray):
        self.r_func = r_func
        self.g_func = g_func
        self.b_func = b_func

PixelRGB = Tuple[int, int, int]
Image = List[List[PixelRGB]]

class BestMatchRequest():
    def __init__(self, tile_512 : Image):
        self.tile_512 = tile_512
    
    def to_dict(self):
        # Convert the Image attribute to a serializable format
        serializable_image = [[list([int(pixel[0]), int(pixel[1]), int(pixel[2])]) for pixel in row] for row in self.tile_512]
        return {'tile512': serializable_image}

class BestMatchResponse:
    def __init__(self, cdf: TileCdf, similarity: float):
        self.cdf = cdf
        self.similarity = similarity

    def from_json(dct):
        cdf_data = dct['cdf']
        r = np.array(cdf_data['r'])
        g = np.array(cdf_data['g'])
        b = np.array(cdf_data['b'])
        return BestMatchResponse(cdf=TileCdf(r=r, g=g, b=b), similarity=dct['similarity'])


def openGdalDataset(inputRaster: Union[str, QgsRasterLayer]) -> Dataset:
    inputRasterPath = (
        inputRaster.dataProvider().dataSourceUri()
        if isinstance(inputRaster, QgsRasterLayer)
        else inputRaster
    )
    ds = gdal.Open(inputRasterPath)
    return ds

def loadTile(gdalDs: Dataset, band: int, x_off: int, y_off: int, x_size: int, y_size: int) -> np.array:
    np_arr = np.array(gdalDs.GetRasterBand(band).ReadAsArray(x_off, y_off, x_size, y_size).transpose())
    return np_arr

def writeApplyingFunction(ds_in: Dataset, hm_f: HistMatchingFunction, outFileName: str):
    filenameNoExtension = outFileName.split('.')[0]
    actualFilename = filenameNoExtension + '.TIF'

    rb1 = ds_in.GetRasterBand(1)
    width = rb1.XSize
    height = rb1.YSize

    driver = gdal.GetDriverByName("GTiff")
    outdata = driver.Create(actualFilename, width, height, 3, gdal.GDT_UInt16)
    outdata.SetGeoTransform(ds_in.GetGeoTransform())
    outdata.SetProjection(ds_in.GetProjection())

    for x_off in range(0, width, REWRITE_STEP_SIZE):
        if (x_off + REWRITE_STEP_SIZE > width):
            continue
        
        for y_off in range(0, height, REWRITE_STEP_SIZE):
            if (y_off + REWRITE_STEP_SIZE > height):
                continue
            
            arr_r = np.array(ds_in.GetRasterBand(1).ReadAsArray(x_off, y_off, REWRITE_STEP_SIZE, REWRITE_STEP_SIZE))
            arr_g = np.array(ds_in.GetRasterBand(2).ReadAsArray(x_off, y_off, REWRITE_STEP_SIZE, REWRITE_STEP_SIZE))
            arr_b = np.array(ds_in.GetRasterBand(3).ReadAsArray(x_off, y_off, REWRITE_STEP_SIZE, REWRITE_STEP_SIZE))

            [rows, cols] = arr_r.shape

            for x in range(rows):
                for y in range(cols):
                    arr_r[x, y] = hm_f.r_func[arr_r[x, y]]
                    arr_g[x, y] = hm_f.g_func[arr_g[x, y]]
                    arr_b[x, y] = hm_f.b_func[arr_b[x, y]]
            
            outdata.GetRasterBand(1).WriteArray(arr_r, x_off, y_off)
            outdata.GetRasterBand(2).WriteArray(arr_g, x_off, y_off)
            outdata.GetRasterBand(3).WriteArray(arr_b, x_off, y_off)

    outdata.FlushCache() ##saves to disk!!
    outdata = None

def apply_histogram_matching_function(tgt_img, f):
  matched_image = np.zeros_like(tgt_img)

  r_band = tgt_img[:,:,0]
  for row_idx in r_band.shape[0]:
    for col_idx in r_band.shape[1]:
      matched_image[row_idx, col_idx, 0] = int(f.r_func[r_band[row_idx, col_idx]])

  g_band = tgt_img[:,:,1]
  for row_idx in g_band.shape[0]:
    for col_idx in g_band.shape[1]:
      matched_image[row_idx, col_idx, 1] = int(f.g_func[g_band[row_idx, col_idx]])

  b_band = tgt_img[:,:,0]
  for row_idx in b_band.shape[0]:
    for col_idx in b_band.shape[1]:
      matched_image[row_idx, col_idx, 2] = int(f.b_func[b_band[row_idx, col_idx]])

  return matched_image


class CBERSColorCorrectorAlgorithm(QgsProcessingAlgorithm):
    
    OUTPUT = 'OUTPUT'
    INPUT = 'INPUT'

    def initAlgorithm(self, config):
        self.addParameter(
            QgsProcessingParameterFile(
                self.INPUT,
                self.tr('CBERS IMAGE FILE'),
                behavior=QgsProcessingParameterFile.File,
                fileFilter='All (*.*)'
            )
        )

        self.addParameter(
            QgsProcessingParameterFileDestination(
                self.OUTPUT,
                self.tr('OUTPUT DESTINATION')
            )
        )

        self.addParameter(
            QgsProcessingParameterNumber(
                'SAMPLE_TILES',
                self.tr('Number of sample tiles'),
                minValue=1,
                defaultValue=20
            )
        )

        self.addParameter(
            QgsProcessingParameterString(
                'SERVER_URL',
                self.tr('Server URL'),
                defaultValue='https://server-url/endpoint'
            )
    )
    
    def euclidean_distance(self, v1, v2):
        """Calculate the Euclidean distance between two vectors."""
        return np.sqrt(np.sum((v1 - v2) ** 2))
    
    def tile_hist_distance(self, h1 : TileHistogram, h2 : TileHistogram):
        """Calculate the Distance between two tile histograms."""
        dist_r = self.euclidean_distance(h1.r_hist, h2.r_hist)
        dist_g = self.euclidean_distance(h1.g_hist, h2.g_hist)
        dist_b = self.euclidean_distance(h1.b_hist, h2.b_hist)

        return dist_r + dist_g + dist_b
    
    def find_most_diverse(self, all_histograms, M):
      """Find the indexes of the M most diverse vectors from the list."""

      elem_count = len(all_histograms)
      
      # Create a list of indices
      indices = list(range(elem_count))

      if (elem_count <= M):
          return indices
      
      # Start with a randomly chosen histogram index
      diverse_picks = [indices.pop(np.random.randint(len(indices)))]
      
      # Repeat until we have selected M histograms
      while len(diverse_picks) < M:
          # For each tile histogram, calculate the minimum distance to the selected ones
          min_distances = [min(self.tile_hist_distance(all_histograms[i], all_histograms[selected]) 
                              for selected in diverse_picks) for i in indices]
          
          # Select the index of the vector with the maximum minimum distance
          max_index = np.argmax(min_distances)
          diverse_picks.append(indices.pop(max_index))

      return diverse_picks
    
    def get_histogram_matching_function_band(self, cdf1_band : np.ndarray, cdf2_band : np.ndarray):
        matching_function_band = np.zeros_like(cdf1_band)

        for i in range(256):
            diff = np.abs(cdf1_band[i] - cdf2_band)
            idx = np.argmin(diff)
            matching_function_band[i] = idx

        return matching_function_band
    
    def get_histogram_matching_function(self, cdf1 : TileCdf, cdf2 : TileCdf):
        r_func = self.get_histogram_matching_function_band(cdf1.r, cdf2.r)
        g_func = self.get_histogram_matching_function_band(cdf1.g, cdf2.g)
        b_func = self.get_histogram_matching_function_band(cdf1.b, cdf2.b)

        matching_function = HistMatchingFunction(r_func, g_func, b_func)

        return matching_function
    
    def compute_average_function(self, hist_matching_functions : List[HistMatchingFunction]):
        avg_f = hist_matching_functions[0]

        for value in range(256):
            avg_f.r_func[value] = np.mean([func.r_func[value] for func in hist_matching_functions])
            avg_f.g_func[value] = np.mean([func.g_func[value] for func in hist_matching_functions])
            avg_f.b_func[value] = np.mean([func.b_func[value] for func in hist_matching_functions])

        return avg_f

    def processAlgorithm(self, parameters, context, feedback):
        input_file = self.parameterAsFile(parameters, self.INPUT, context)
        output_file = self.parameterAsFileOutput(parameters, self.OUTPUT, context)
        sample_tiles = self.parameterAsInt(parameters, 'SAMPLE_TILES', context)
        server_url = self.parameterAsString(parameters, 'SERVER_URL', context)

        # Open the raster
        feedback.pushInfo('Opening raster file...')
        input_layer = QgsRasterLayer(input_file, "input")

        # Ensure the layer was loaded successfully
        if not input_layer.isValid():
            raise QgsProcessingException("Could not load layer")
        
        gdal_ds = openGdalDataset(input_layer)
        rb1 = gdal_ds.GetRasterBand(1)
        width = rb1.XSize
        height = rb1.YSize

        all_histograms = []
        all_images = []

        min_possible_x_start = 0
        max_possible_x_start = width - TILE_SIZE
        min_possible_y_start = 0
        max_possible_y_start = height - TILE_SIZE

        # Ramdomly read some chunks...
        feedback.pushInfo('Taking some samples...')
        for chunk_n in range(0, RANDOM_CHUNKS):
            random_x_start = np.random.randint(min_possible_x_start, max_possible_x_start)
            random_y_start = np.random.randint(min_possible_y_start, max_possible_y_start)
            
            data_red = loadTile(gdal_ds, 1, random_x_start, random_y_start, TILE_SIZE, TILE_SIZE)
            data_gre = loadTile(gdal_ds, 2, random_x_start, random_y_start, TILE_SIZE, TILE_SIZE)
            data_blu = loadTile(gdal_ds, 3, random_x_start, random_y_start, TILE_SIZE, TILE_SIZE)

            count_zero = np.sum(data_red == 0)
            count_non_zero = np.sum(data_red != 0)

            zero_ratio = count_zero / count_non_zero
            if (zero_ratio > MISSING_PIXEL_TOL):    # Handling of black regions
                continue

            hist_red, bin_edges = np.histogram(data_red, bins=256, range=(0,255), density=True)
            hist_gre, bin_edges = np.histogram(data_gre, bins=256, range=(0,255), density=True)
            hist_blu, bin_edges = np.histogram(data_blu, bins=256, range=(0,255), density=True)

            tile_hist = TileHistogram(hist_red, hist_gre, hist_blu)

            all_histograms.append(tile_hist)

            # Create an Image object:
            image = []
            for i in range(TILE_SIZE):
                row = []
                for j in range(TILE_SIZE):
                    pixel_rgb = (data_red[i,j], data_gre[i,j], data_blu[i,j])
                    row.append(pixel_rgb)
                image.append(row)
            
            # Append the Image object to the all_images list:
            all_images.append(image)
        
        feedback.pushInfo('Finding diverse...')

        diverse_indexes = self.find_most_diverse(all_histograms, sample_tiles)
        diverse_histograms = [all_histograms[i] for i in diverse_indexes]
        diverse_images = [all_images[i] for i in diverse_indexes]

        hist_matching_functions = []

        feedback.pushInfo('Getting best matches...')

        for hist_index in range(0, len(diverse_histograms)):
            hist : TileHistogram = diverse_histograms[hist_index]
            img : Image = diverse_images[hist_index]

            r_cdf = np.cumsum(hist.r_hist)
            g_cdf = np.cumsum(hist.g_hist)
            b_cdf = np.cumsum(hist.b_hist)
            cdf = TileCdf(r_cdf, g_cdf, b_cdf)

            best_match_req = BestMatchRequest(tile_512=img)

            url = server_url
            req_obj = best_match_req.to_dict()
            headers = {'Content-type': 'application/json', 'Accept-Charset': 'UTF-8'}
            basic = HTTPBasicAuth('msereno', 'pfc2023')

            res = requests.post(url, json=req_obj, headers=headers, verify=False, auth=basic)
            best_match_res_json = res.json()

            best_match_res = BestMatchResponse.from_json(best_match_res_json)

            res_cdf : TileCdf = best_match_res.cdf
            res_similarity = best_match_res.similarity

            hist_mapping_f = self.get_histogram_matching_function(cdf, res_cdf)
            hist_matching_functions.append(hist_mapping_f)

        feedback.pushInfo('Computing average function...')

        avg_hist_matching_f = self.compute_average_function(hist_matching_functions)

        feedback.pushInfo('Building output...')

        writeApplyingFunction(gdal_ds, avg_hist_matching_f, output_file)

        return {self.OUTPUT: output_file}
        

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Adjust Raster Coloring'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'CBERS Color Corrector'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return CBERSColorCorrectorAlgorithm()
