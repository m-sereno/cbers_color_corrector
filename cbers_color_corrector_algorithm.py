# -*- coding: utf-8 -*-

"""
/***************************************************************************
 CBERSColorCorrector
                                 A QGIS plugin
 This plugin corrects the color from CBERS images to match the database
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-08-01
        copyright            : (C) 2023 by Mateus Sereno
        email                : mateus.sereno@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Mateus Sereno'
__date__ = '2023-08-01'
__copyright__ = '(C) 2023 by Mateus Sereno'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import numpy as np
import requests
import os
from pathlib import Path
import re
import json
from requests.auth import HTTPBasicAuth
import time
from threading import Lock
from concurrent.futures import ThreadPoolExecutor
from typing import Dict, List, Tuple, Union

from osgeo import gdal, ogr
from osgeo.gdal import Dataset

from qgis import processing
from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (Qgis,
                       QgsProcessing,
                       QgsFeatureSink,
                       QgsProcessingAlgorithm,
                       QgsProcessingFeedback,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterFile,
                       QgsProcessingParameterFileDestination,
                       QgsProcessingParameterFolderDestination,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterString,
                       QgsRasterLayer,
                       QgsRasterDataProvider,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingException,
                       QgsRasterFileWriter,
                       QgsRasterBlock,
                       QgsRasterPipe,
                       QgsRectangle)

TILE_SIZE = 512
REWRITE_STEP_SIZE = 1024
RANDOM_CHUNKS = 100
MISSING_PIXEL_TOL = 0.01

PROG_PCT_OPEN_RASTER = 1
PROG_PCT_RANDOM_CHUN = 9
PROG_PCT_GET_DIVERSE = 1
PROG_PCT_BEST_MATCHS = 19
PROG_PCT_SPLIT_INPUT = 10
PROG_PCT_APPLY_FUNCT = 50
PROG_PCT_MERGE_OUTPT = 10

class TileHistogram():
    def __init__(self, r_hist : np.ndarray, g_hist : np.ndarray, b_hist : np.ndarray):
        self.r_hist = r_hist
        self.g_hist = g_hist
        self.b_hist = b_hist

class TileCdf():
    def __init__(self, r : np.ndarray, g : np.ndarray, b : np.ndarray):
        self.r = r
        self.g = g
        self.b = b

class HistMatchingFunction():
    def __init__(self, r_func : np.ndarray, g_func : np.ndarray, b_func : np.ndarray):
        self.r_func = r_func
        self.g_func = g_func
        self.b_func = b_func

PixelRGB = Tuple[int, int, int]
Image = List[List[PixelRGB]]

class BestMatchRequest():
    def __init__(self, tile_512 : Image):
        self.tile_512 = tile_512
    
    def to_dict(self):
        # Convert the Image attribute to a serializable format
        serializable_image = [[list([int(pixel[0]), int(pixel[1]), int(pixel[2])]) for pixel in row] for row in self.tile_512]
        return {'tile512': serializable_image}

class BestMatchResponse:
    def __init__(self, cdf: TileCdf, similarity: float):
        self.cdf = cdf
        self.similarity = similarity

    def from_json(dct):
        cdf_data = dct['cdf']
        r = np.array(cdf_data['r'])
        g = np.array(cdf_data['g'])
        b = np.array(cdf_data['b'])
        return BestMatchResponse(cdf=TileCdf(r=r, g=g, b=b), similarity=dct['similarity'])


def openGdalDatasetReadonly(inputRaster: Union[str, QgsRasterLayer]) -> Dataset:
    inputRasterPath = (
        inputRaster.dataProvider().dataSourceUri()
        if isinstance(inputRaster, QgsRasterLayer)
        else inputRaster
    )
    ds = gdal.Open(inputRasterPath, gdal.GA_ReadOnly)
    return ds

def loadTile(gdalDs: Dataset, band: int, x_off: int, y_off: int, x_size: int, y_size: int) -> np.array:
    np_arr = np.array(gdalDs.GetRasterBand(band).ReadAsArray(x_off, y_off, x_size, y_size).transpose())
    return np_arr

def splitSceneFileIntoMultipleFiles(path_file_in: str, path_folder_out: str, context, feedback) -> list[str]:
    p_filein = Path(path_file_in)
    filename = p_filein.name
    filename_no_suffix = p_filein.with_suffix('').name
    myresult = processing.run("gdal:retile", {'INPUT': path_file_in,
               'TILE_SIZE_X': REWRITE_STEP_SIZE,
               'TILE_SIZE_Y': REWRITE_STEP_SIZE,
               'OVERLAP': 0,
               'LEVELS': 1,
               'OUTPUT': path_folder_out},
               context=context, feedback=feedback, is_child_algorithm=True)
    
    pattern = f"^{filename_no_suffix}_\d+_\d+.tif$"
    
    every_file_here = os.listdir(path_folder_out)
    result_files = []
    for out_path in every_file_here:
      s_res = re.search(pattern, out_path)
      if s_res != None:
        result_files.append(out_path)

    return result_files

def applyFunctionOnFile(output_def_tuples, output_base, hm_f: HistMatchingFunction, feedback: QgsProcessingFeedback):
    progress_before = feedback.progress()

    def do_work(it_tuple):
        if feedback.isCanceled():
            return
        
        filename = it_tuple[0]
        full_path = it_tuple[1]
        out_full_path = f"{output_base}/OUT_{filename}"

        thread_ds = openGdalDatasetReadonly(full_path)
        rb1 = thread_ds.GetRasterBand(1)
        width = rb1.XSize
        height = rb1.YSize
        
        arr_r = np.array(thread_ds.GetRasterBand(1).ReadAsArray())
        arr_g = np.array(thread_ds.GetRasterBand(2).ReadAsArray())
        arr_b = np.array(thread_ds.GetRasterBand(3).ReadAsArray())

        [rows, cols] = arr_r.shape

        for x in range(rows):
            for y in range(cols):
                arr_r[x, y] = hm_f.r_func[int(arr_r[x, y])]
                arr_g[x, y] = hm_f.g_func[int(arr_r[x, y])]
                arr_b[x, y] = hm_f.b_func[int(arr_r[x, y])]
        
        driver = gdal.GetDriverByName("GTiff")
        outdata = driver.Create(out_full_path, width, height, 3, gdal.GDT_UInt16)
        outdata.SetGeoTransform(thread_ds.GetGeoTransform())
        outdata.SetProjection(thread_ds.GetProjection())

        outdata.GetRasterBand(1).WriteArray(arr_r)
        outdata.GetRasterBand(2).WriteArray(arr_g)
        outdata.GetRasterBand(3).WriteArray(arr_b)

        outdata.FlushCache() ##saves to disk!!
        outdata = None

    
    pool = ThreadPoolExecutor(max_workers=8)
    results = pool.map(do_work, output_def_tuples)

    it_len = len(output_def_tuples)
    it_idx = 0
    
    for _ in results:
        it_idx += 1
        progress_now = progress_before + round(PROG_PCT_APPLY_FUNCT * it_idx / it_len)
        feedback.setProgress(progress_now)
        feedback.setProgressText(f"Applying color adjustment function... {it_idx} / {it_len}")
    
    pool.shutdown()
    

def writeApplyingFunction(rl_in: QgsRasterLayer, hm_f: HistMatchingFunction, outFileName: str, tempFolder : str, feedback: QgsProcessingFeedback):
    filenameNoExtension = outFileName.split('.')[0]
    actualFilename = filenameNoExtension + '.tif'

    input_path = rl_in.dataProvider().dataSourceUri()
    output_path = tempFolder

    feedback.setProgressText(f"Splitting scene into multiple files. This might take a couple minutes...")

    splitted_files = splitSceneFileIntoMultipleFiles(input_path, output_path)
    feedback.pushDebugInfo(str(splitted_files))

    progress_before = feedback.progress()
    feedback.setProgress(progress_before + PROG_PCT_SPLIT_INPUT)
    feedback.setProgressText(f"Applying color adjustment function...")
    
    iteration_tuples = []
    for filename in splitted_files:
      full_path = f"{output_path}/{filename}"
      iteration_tuples.append((filename, full_path))
    
    def do_work(it_tuple):
        if feedback.isCanceled():
            return
        
        filename = it_tuple[0]
        full_path = it_tuple[1]
        out_full_path = f"{output_path}/OUT_{filename}"

        thread_ds = openGdalDatasetReadonly(full_path)
        rb1 = thread_ds.GetRasterBand(1)
        width = rb1.XSize
        height = rb1.YSize
        
        arr_r = np.array(thread_ds.GetRasterBand(1).ReadAsArray())
        arr_g = np.array(thread_ds.GetRasterBand(2).ReadAsArray())
        arr_b = np.array(thread_ds.GetRasterBand(3).ReadAsArray())

        [rows, cols] = arr_r.shape

        for x in range(rows):
            for y in range(cols):
                arr_r[x, y] = hm_f.r_func[int(arr_r[x, y])]
                arr_g[x, y] = hm_f.g_func[int(arr_r[x, y])]
                arr_b[x, y] = hm_f.b_func[int(arr_r[x, y])]
        
        driver = gdal.GetDriverByName("GTiff")
        outdata = driver.Create(out_full_path, width, height, 3, gdal.GDT_UInt16)
        outdata.SetGeoTransform(thread_ds.GetGeoTransform())
        outdata.SetProjection(thread_ds.GetProjection())

        outdata.GetRasterBand(1).WriteArray(arr_r)
        outdata.GetRasterBand(2).WriteArray(arr_g)
        outdata.GetRasterBand(3).WriteArray(arr_b)

        outdata.FlushCache() ##saves to disk!!
        outdata = None

    
    pool = ThreadPoolExecutor(max_workers=8)
    results = pool.map(do_work, iteration_tuples)

    it_len = len(iteration_tuples)
    it_idx = 0
    
    for _ in results:
        it_idx += 1
        progress_now = progress_before + round(PROG_PCT_APPLY_FUNCT * it_idx / it_len)
        feedback.setProgress(progress_now)
        feedback.setProgressText(f"Applying color adjustment function... {it_idx} / {it_len}")
    
    pool.shutdown()


def apply_histogram_matching_function(tgt_img, f):
  matched_image = np.zeros_like(tgt_img)

  r_band = tgt_img[:,:,0]
  for row_idx in r_band.shape[0]:
    for col_idx in r_band.shape[1]:
      matched_image[row_idx, col_idx, 0] = int(f.r_func[r_band[row_idx, col_idx]])

  g_band = tgt_img[:,:,1]
  for row_idx in g_band.shape[0]:
    for col_idx in g_band.shape[1]:
      matched_image[row_idx, col_idx, 1] = int(f.g_func[g_band[row_idx, col_idx]])

  b_band = tgt_img[:,:,0]
  for row_idx in b_band.shape[0]:
    for col_idx in b_band.shape[1]:
      matched_image[row_idx, col_idx, 2] = int(f.b_func[b_band[row_idx, col_idx]])

  return matched_image


class CBERSColorCorrectorAlgorithm(QgsProcessingAlgorithm):
    
    OUTPUT = 'OUTPUT'
    INPUT = 'INPUT'
    TEMP = 'TEMP'
    SAMPLE_TILES = 'SAMPLE_TILES'
    SERVER_URL = 'SERVER_URL'

    def initAlgorithm(self, config):
        self.addParameter(
            QgsProcessingParameterFile(
                self.INPUT,
                self.tr('CBERS IMAGE FILE'),
                behavior=QgsProcessingParameterFile.File,
                fileFilter='All (*.*)'
            )
        )

        self.addParameter(
            QgsProcessingParameterFolderDestination(
                self.TEMP,
                self.tr('TEMPORARY DESTINATION')
            )
        )

        self.addParameter(
            QgsProcessingParameterFileDestination(
                self.OUTPUT,
                self.tr('OUTPUT DESTINATION')
            )
        )

        self.addParameter(
            QgsProcessingParameterNumber(
                self.SAMPLE_TILES,
                self.tr('Number of sample tiles'),
                minValue=1,
                defaultValue=20
            )
        )

        self.addParameter(
            QgsProcessingParameterString(
                self.SERVER_URL,
                self.tr('Server URL'),
                defaultValue='https://django.django.pfc.msereno.com/api/cbers-cc-plugin/tiles-512/similar/'
            )
    )
    
    def euclidean_distance(self, v1, v2):
        """Calculate the Euclidean distance between two vectors."""
        return np.sqrt(np.sum((v1 - v2) ** 2))
    
    def tile_hist_distance(self, h1 : TileHistogram, h2 : TileHistogram):
        """Calculate the Distance between two tile histograms."""
        dist_r = self.euclidean_distance(h1.r_hist, h2.r_hist)
        dist_g = self.euclidean_distance(h1.g_hist, h2.g_hist)
        dist_b = self.euclidean_distance(h1.b_hist, h2.b_hist)

        return dist_r + dist_g + dist_b
    
    def find_most_diverse(self, all_histograms, M):
      """Find the indexes of the M most diverse vectors from the list."""

      elem_count = len(all_histograms)
      
      # Create a list of indices
      indices = list(range(elem_count))

      if (elem_count <= M):
          return indices
      
      # Start with a randomly chosen histogram index
      diverse_picks = [indices.pop(np.random.randint(len(indices)))]
      
      # Repeat until we have selected M histograms
      while len(diverse_picks) < M:
          # For each tile histogram, calculate the minimum distance to the selected ones
          min_distances = [min(self.tile_hist_distance(all_histograms[i], all_histograms[selected]) 
                              for selected in diverse_picks) for i in indices]
          
          # Select the index of the vector with the maximum minimum distance
          max_index = np.argmax(min_distances)
          diverse_picks.append(indices.pop(max_index))

      return diverse_picks
    
    def get_histogram_matching_function_band(self, cdf1_band : np.ndarray, cdf2_band : np.ndarray):
        matching_function_band = np.zeros_like(cdf1_band)

        for i in range(256):
            diff = np.abs(cdf1_band[i] - cdf2_band)
            idx = np.argmin(diff)
            matching_function_band[i] = idx

        return matching_function_band
    
    def get_histogram_matching_function(self, cdf1 : TileCdf, cdf2 : TileCdf):
        r_func = self.get_histogram_matching_function_band(cdf1.r, cdf2.r)
        g_func = self.get_histogram_matching_function_band(cdf1.g, cdf2.g)
        b_func = self.get_histogram_matching_function_band(cdf1.b, cdf2.b)

        matching_function = HistMatchingFunction(r_func, g_func, b_func)

        return matching_function
    
    def compute_average_function(self, hist_matching_functions : List[HistMatchingFunction]):
        avg_f = hist_matching_functions[0]

        for value in range(256):
            avg_f.r_func[value] = np.mean([func.r_func[value] for func in hist_matching_functions])
            avg_f.g_func[value] = np.mean([func.g_func[value] for func in hist_matching_functions])
            avg_f.b_func[value] = np.mean([func.b_func[value] for func in hist_matching_functions])

        return avg_f

    def processAlgorithm(self, parameters, context, feedback):
        input_file = self.parameterAsFile(parameters, self.INPUT, context)
        output_file = self.parameterAsFileOutput(parameters, self.OUTPUT, context)
        temp_folder = self.parameterAsFile(parameters, self.TEMP, context)
        sample_tiles = self.parameterAsInt(parameters, self.SAMPLE_TILES, context)
        server_url = self.parameterAsString(parameters, self.SERVER_URL, context)

        p_file_out = Path(output_file)
        out_file_parent = p_file_out.parent

        current_progress = 0

        # Open the raster
        feedback.setProgressText("Opening raster file")
        feedback.setProgress(current_progress)
        input_layer = QgsRasterLayer(input_file, "input")

        # Ensure the layer was loaded successfully
        if not input_layer.isValid():
            raise QgsProcessingException("Could not load layer")
        
        gdal_ds = openGdalDatasetReadonly(input_layer)
        rb1 = gdal_ds.GetRasterBand(1)
        width = rb1.XSize
        height = rb1.YSize

        all_histograms = []
        all_images = []

        min_possible_x_start = 0
        max_possible_x_start = width - TILE_SIZE
        min_possible_y_start = 0
        max_possible_y_start = height - TILE_SIZE

        current_progress += PROG_PCT_OPEN_RASTER

        # Ramdomly read some chunks...
        feedback.setProgressText("Taking some samples")
        feedback.setProgress(current_progress)
        step_size = PROG_PCT_RANDOM_CHUN / RANDOM_CHUNKS
        for chunk_n in range(0, RANDOM_CHUNKS):
            feedback.setProgress(current_progress + step_size * chunk_n)
            if feedback.isCanceled():
                return
            random_x_start = np.random.randint(min_possible_x_start, max_possible_x_start)
            random_y_start = np.random.randint(min_possible_y_start, max_possible_y_start)
            
            data_red = loadTile(gdal_ds, 1, random_x_start, random_y_start, TILE_SIZE, TILE_SIZE)
            data_gre = loadTile(gdal_ds, 2, random_x_start, random_y_start, TILE_SIZE, TILE_SIZE)
            data_blu = loadTile(gdal_ds, 3, random_x_start, random_y_start, TILE_SIZE, TILE_SIZE)

            count_zero = np.sum(data_red == 0)
            count_non_zero = np.sum(data_red != 0)

            zero_ratio = count_zero / count_non_zero
            if (zero_ratio > MISSING_PIXEL_TOL):    # Handling of black regions
                continue

            hist_red, bin_edges = np.histogram(data_red, bins=256, range=(0,255), density=True)
            hist_gre, bin_edges = np.histogram(data_gre, bins=256, range=(0,255), density=True)
            hist_blu, bin_edges = np.histogram(data_blu, bins=256, range=(0,255), density=True)

            tile_hist = TileHistogram(hist_red, hist_gre, hist_blu)

            all_histograms.append(tile_hist)

            # Create an Image object:
            image = []
            for i in range(TILE_SIZE):
                row = []
                for j in range(TILE_SIZE):
                    pixel_rgb = (data_red[i,j], data_gre[i,j], data_blu[i,j])
                    row.append(pixel_rgb)
                image.append(row)
            
            # Append the Image object to the all_images list:
            all_images.append(image)
        
        current_progress += PROG_PCT_RANDOM_CHUN

        feedback.setProgressText("Finding diverse tiles")
        feedback.setProgress(current_progress)

        found_count = len(all_histograms)
        feedback.pushInfo(f"Found {found_count} valid tiles.")

        diverse_indexes = self.find_most_diverse(all_histograms, sample_tiles)
        diverse_histograms = [all_histograms[i] for i in diverse_indexes]
        diverse_images = [all_images[i] for i in diverse_indexes]

        hist_matching_functions = []

        current_progress += PROG_PCT_GET_DIVERSE

        diverse_count = len(diverse_images)
        feedback.pushInfo(f"Found {diverse_count} diverse tiles.")

        feedback.setProgressText("Getting best matches")
        feedback.setProgress(current_progress)

        step_count = len(diverse_histograms)
        step_size = PROG_PCT_BEST_MATCHS / step_count
        for hist_index in range(0, step_count):
            feedback.setProgress(current_progress + step_size * hist_index)
            if feedback.isCanceled():
                return

            hist : TileHistogram = diverse_histograms[hist_index]
            img : Image = diverse_images[hist_index]

            r_cdf = np.cumsum(hist.r_hist)
            g_cdf = np.cumsum(hist.g_hist)
            b_cdf = np.cumsum(hist.b_hist)
            cdf = TileCdf(r_cdf, g_cdf, b_cdf)

            best_match_req = BestMatchRequest(tile_512=img)

            url = server_url
            req_obj = best_match_req.to_dict()
            headers = {'Content-type': 'application/json', 'Accept-Charset': 'UTF-8'}
            basic_user = 'msereno'
            basic_pass = 'pfc2023'
            basic = HTTPBasicAuth(basic_user, basic_pass)

            if (hist_index == 0):
                feedback.pushInfo("Sample payload:")
                feedback.pushInfo(f"=== URL: {url}")
                feedback.pushInfo(f"=== json: {json.dumps(req_obj)}")
                feedback.pushInfo(f"=== headers: {json.dumps(headers)}")
                feedback.pushInfo(f"=== auth: [{basic_user}] | [{basic_pass}]")

            res = requests.post(url, json=req_obj, headers=headers, verify=False, auth=basic)

            if (hist_index == 0):
                feedback.pushInfo("Sample response:")
                feedback.pushInfo(f"=== elapsed: {str(res.elapsed)}")
                feedback.pushInfo(f"=== headers: {json.dumps(dict(res.headers))}")
                feedback.pushInfo(f"=== status_code: {str(res.status_code)}")

            best_match_res_json = res.json()
            if (hist_index == 0):
                feedback.pushInfo(f"=== content: {json.dumps(best_match_res_json)}")

            best_match_res = BestMatchResponse.from_json(best_match_res_json)

            res_cdf : TileCdf = best_match_res.cdf
            res_similarity = best_match_res.similarity

            hist_mapping_f = self.get_histogram_matching_function(cdf, res_cdf)
            hist_matching_functions.append(hist_mapping_f)

        feedback.pushInfo('Computing average function...')

        avg_hist_matching_f = self.compute_average_function(hist_matching_functions)

        current_progress += PROG_PCT_BEST_MATCHS
        feedback.setProgress(current_progress)
        feedback.setProgressText("Splitting scene into multiple files. This might take a couple minutes...")

        splitted_files = splitSceneFileIntoMultipleFiles(input_file, temp_folder, context, feedback)

        iteration_tuples = []
        for filename in splitted_files:
          full_path = f"{out_file_parent.as_posix()}/{filename}"
          iteration_tuples.append((filename, full_path))
        
        applyFunctionOnFile(iteration_tuples, temp_folder, avg_hist_matching_f, feedback)

        return {self.OUTPUT: output_file}
        

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Adjust Raster Coloring'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'CBERS Color Corrector'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return CBERSColorCorrectorAlgorithm()
